

define(['d3.v3.min.js', 'BDR', 'bdr-herbarium.js'], function(d3, bdr, _) { 
  
  
  var SIZE_BY_COUNT = false; // are the tiles sized according to the number of specimens?
  
  // Given a query, return a title/caption to put at the top
  
  function getTreemapTitleFromQuery(qy) {

    var title;
    
    if ( qy === undefined || 
        (qy.family === undefined && qy.genus === undefined && qy.species === undefined)) {
      title = 'Welcome to the Brown University Herbarium';
    } else {
      if (qy.family !== undefined && qy.genus !== undefined && qy.species !== undefined)
        title = 'Specimen in species ' + [qy.family, qy.genus, qy.species].join(' ');
      else if (qy.family !== undefined && qy.genus !== undefined)
        title = 'Specimens in genus ' + qy.family + ' ' + qy.genus;
      else if (qy.family !== undefined)
        title = 'Specimens in family ' + qy.family;
    }

    return title;
  }
  
  // Convert tree (taxonomic) structure (e.g. from BDR.herbarium.getSpecimens())
  //  into treemap-ready structure

  function getTreemapStructureFromQuery(qy, onComplete) {

    var root = { name: getTreemapTitleFromQuery(qy), children: [], query: qy }, 
        f, g, s, 
        fObject, gObject, sObject;
    
    function convertToTreemapStructure (tree) {

      for (f in tree) {

        fObject = { 'name': f, children: [], type: 'family' };

        for (g in tree[f]) {

          gObject = { 'name': g, children: [], type: 'genus' };

          for (s in tree[f][g]) {

            sObject = { 
              name: s,
              size: (SIZE_BY_COUNT ? tree[f][g][s].size : 1), 
              imageUrls: tree[f][g][s].imageUrls,
              type: 'species'
            };

            gObject.children.push(sObject);
          }

          fObject.children.push(gObject);
        }

        root.children.push(fObject);
      }

      onComplete(root);
    }
    
    BDR.herbarium.getSpecimens(qy, convertToTreemapStructure);
  }

  // Take the data structure generated by getTreemapStructureFromQuery()
  //  and produce a treemap in the DOM

  function drawTreeMap(root, domNode) {

    var margin = { top: 0, right: 0, bottom: 0, left: 0 },
        // The following is pulling the dimensions from the #treemap div, not the
        //  actual treemap area (#treeroot)
        // width  = domNode.offsetWidth  - margin.left - margin.right,
        // height = domNode.offsetHeight - margin.top - margin.bottom,
        width = 7680, // FIX THIS
        height = 3140, // FIX THIS
        domNodeD3 = d3.select(domNode),
        treemap, treeGeometry, treeClasses, div, labels, node, qy;
    
    // Erase contents of container -- THIS SHOULD BE FIXED -- domNodeD3.empty()?
    
    d3.select('#treeroot').remove();
    d3.select('#treetitle').remove();
    
    // Update heading
    
    d3.select(domNode).append('div').attr('id','treetitle').text(root.name);
    
    // Get coordinates of elements for treemap and put into data structure

    treemap = d3.layout.treemap()
                .size([width, height])
                .sticky(true)
                .value(function(d) { return d.size });

    // Given data, get the geometry of the tiles
    // TODO: cache this using localstorage() -- or maybe sessionstorage()?
    // There may have to be a way of freezing and unfreezing the data structure,
    //  as there are functions embedded in there.
    
    treeGeometry = treemap.nodes(root);
    console.log('TREE GEOMETRY');
    console.log(treeGeometry);
    
    // Create containing div

    div = domNodeD3.append('div') // d3.select(domNode).append('div')
                   .attr('id','treeroot');

    // Assign class indicating depth

    qy = root.query;
    treeClasses = { 'depth-root': false, 'depth-family': false, 
                    'depth-genus': false, 'depth-species': false };
    
    if (qy === undefined || (qy.species === undefined && qy.genus === undefined && qy.family === undefined)) {
      treeClasses['depth-root'] = true;
    } else {
      if (qy.species !== undefined && qy.genus !== undefined && qy.family !== undefined) {
        treeClasses['depth-species'] = true;
      } else if (qy.species === undefined && qy.genus !== undefined && qy.family !== undefined) {
        treeClasses['depth-genus'] = true;
      } else if (qy.species === undefined && qy.genus === undefined && qy.family !== undefined) {
        treeClasses['depth-family'] = true;
      }
    }

    domNodeD3.classed(treeClasses);
    
    // Now put the labels in

    labels = div.append('div').attr('class','labels');

    labels.datum(root).selectAll('.nodelabel')
        // .data(treemap.nodes)
        .data(treeGeometry)
      .enter().append('div')
        .attr('class', function (d) { 
          return 'nodelabel ' + d.type;
        })
        .call(position)
        .append('span')
          .text(function (d) { return d.name; });

    // Now put the images inside according to treemap layout
    
    node = div.datum(root).selectAll('.node')
        // .data(treemap.nodes)
        .data(treeGeometry)
        .enter().append('div')
        .attr('class', function (d) { 
          return 'node ' + d.type;
        })
        .call(position)
        .style('background-image', function(d) {

          var imgUrl, imgHeight;

          if (! d.children) {
            imgHeight = Math.max(0, d.dy - 1);
            imgUrl = (  true || LOAD_IMAGES 
                        ? "url('" + d.imageUrls[0](imgHeight) + "')"
                        : "url('placeholder.png')" );  
          } else {
            imgUrl = null;
          }
          return imgUrl;
        }); /* THIS IS TO MAKE THE IMAGES CLICKABLE - not relevant for wall?
        .on('click', function (d) { 
          selectSpecimen(d.name, d.imageUrls[0]); 
        });*/

    function position(d) {
      this.style('left',   function(d) { return d.x + 'px'; })
          .style('top',    function(d) { return d.y + 'px'; })
          .style('width',  function(d) { return Math.max(0, d.dx - 1) + 'px'; })
          .style('height', function(d) { return Math.max(0, d.dy - 1) + 'px'; });
    }

    d3.selectAll('input').on('change', function change() {
      var value = this.value === 'count'
          ? function() { return 1; }
          : function(d) { return d.size; };

      node
          .data(treemap.value(value).nodes)
        .transition()
          .duration(1500)
          .call(position);
    });
  }
  
  // Return a treemap object
  
  return {
    getTreemapStructureFromQuery: getTreemapStructureFromQuery,
    drawTreeMap: drawTreeMap
  }
});
